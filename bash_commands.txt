BASH


У каждой команды cmd может быть вход (stdin = клавиатура; либо файл) и выход (stdout = экран; либо файл)
cmd < my_file = взять stdin из файла my_file
cmd > my_file = записать stdout в файл my_file, файл целиком перезапишется
cmd >> my_file = записать stdout в my_file, добавив его в конце файла
cmd1 | cmd2 = перенаправить stdout для cmd1 в stdin для cmd2 (можно писать длинные такие цепочки cmd1 | cmd2 | cmd3..., это называется piping)
cmd > /dev/null = перенаправить stdout в никуда
<(cmd1) = этот агрегат вопринимается как временное имя файла, в который cmd1 вывела свой stdout; называется process substitution
$(cmd1) = воспринимается как строка (которую можно использовать в других командах), равная выводу stdout команды cmd1; это command substitution

Также, у каждой команды могут быть опции:
в кратком формате, типа -a
и в длинном формате, типа --long-option


------------------------------------------------------------------
--=====                Справка по командам                 =====--
------------------------------------------------------------------
По любой команде cmd можно получить подробную справку, набрав:
man cmd 
для выхода из режима "man" - написать: q
если справка большая, и надо найти какое-то слово Word1 в режиме "man", то надо написать: /Word1 [ENTER]
    для перехода к следующему найденному слову: n
    для перехода к предыдущему найденному слову: [SHIFT] + n

Для некоторых команд также бывает доступна краткая справка: 
cmd --help


------------------------------------------------------------------
--=====                Управляющие символы                 =====--
------------------------------------------------------------------

Некоторые символы могут иметь дополнительные смысловые нагрузки, зависящие от контекста,
и когда они встречаются в команде в потоке обычного текста, результат может быть неожиданным, напр.
echo ()
не напечатает () на экран; чтобы воспринимать символы как обычный текст, используется:
1) escaping, т.е. добавление обратного слэша перед каждым многозначным символом, напр. echo \(\) = напечатает ()
2) quoting, т.е. взятие текста в кавычки, напр. echo "()" = напечатает ()
следует заметить, что некоторые команды даже в закавыченном тексте воспринимают некоторые символы в качестве управляющих символов,
напр. аргумент -name "file1*" для команды find (см. ниже) воспринимает закавыченную "*" как произвольный шаблон


------------------------------------------------------------------
--=====                  Простые примеры                   =====--
------------------------------------------------------------------

Рассмотрим команду cat и простые примеры (примеры по большому счету бесполезные, они просто для понимания):
cat my_file = вывести файл my_file в stdout (my_file воспринимается как имя параметра для cat)
cat < my_file = вывести my_file в stdout (my_file воспринимается как stdin для cat)
cat < file1 > file2 = взять file1 как stdin, вывести его в файл (перенаправив stdout в file2)
cat <(date) = вывести файл "<(date)" в stdout; упомянутый файл попросту содержит результат команды date


Еще примеры команд:

less file1
просмотр большого файла на экране с прокруткой; для выхода: q


echo Hello World!
команда echo выводит все свои аргументы в stdout


paste file1 file2 file3
считывает файлы, соединяет их построчно, и выводит в stdout, напр.
file1:
1
2
3
file2:
A
B
C
paste file1 file2:
1	A
2	B
3	C
по умолчанию столбцы разделяются при помощи TAB, другой разделитель можно задать в опции -d [...], напр.
paste file1 file2 -d '\n' = разделитель берется равным символу переноса строки, в итоге файлы соединятся с чередованием строк:
1
A
2
B
3
C


date
выводит дату и время в stdout


cal
вывести календарь на текущий месяц
cal 2020
вывести календарь на 2020 год


factor 1234567
разложить число 1234567 на простые множители


seq 5 20
выводит числа в заданном диапазоне в stdout
seq -s, 10 20
то же самое, с заданным разделителем (например, запятой)
seq 5 2 20
числа в заданном диапазоне [5, 20], идущие с заданным инкрементом (2)


history
последние команды
history 19
последние 19 команд


wc file1
(= word count) подсчет кол-ва строк, слов, символов в file1 и вывод этого в stdout
wc -l file1
вывод кол-ва строк

входные данные могут идти не только из файла, но и из stdin, напр.
ls -l | wc -l = подсчитать, сколько файлов найдено командой "ls -l"


tee file1
перенаправить stdin в stdout и в файл file1:
cmd1 > file1 --- весь stdout из cmd1 идет в файл, на экран ничего не пишется
cmd1 | tee file1 --- весь stdout из cmd1 идет и в файл, и на экран (stdout)


------------------------------------------------------------------
--=====                 Файлы и директории                 =====--
------------------------------------------------------------------

cd dir1
перейти в dir1
некоторые сокращения имен директорий:
.  = текущая директория
.. = директория на уровень выше
-  = предыдущая директория
~  = домашняя директория (где лежит, например, .bashrc)
можно их по-разному комбинировать, напр. cd ~/../..

ls
вывод содержимого текущей директории

ls -l
детальный вывод содержимого текущей директории
файлы и папки с именами, начинающимися с точки, считаются скрытыми; чтобы их показать, надо добавить опцию -a


pwd
вывод имени текущей директории


cp file1 file2
копировать один файл в другой

cp -r dir1 dir2
копировать одну директорию (рекурсивно со всеми поддиректориями и файлами) в другую директорию
если dir2 сущствует, то dir1 поместится внутрь нее; если dir2 не существует, то она будет создана как копия dir1 


mv file1 file2
переместить (= переименовать) файл file1 в file2


rm file1
удалить файл

rm -r dir1
удалить директорию (рекурсивно со всеми поддиректориями и файлами)


mkdir dir1
создать пустую директорию dir1


touch file1
если file1 не существует, то создать пустой файл file1,
иначе - изменить время изменения файла на текущее время, не меняя сам файл


du -h dir1
вывести размер dir1 и всех ее поддиректорий; то же можно проделать и для одного отдельного файла

du -h
вывести размер текущей директории и всех ее поддиректорий


------------------------------------------------------------------
--=====            Сравнение, сортировка и т.д.            =====--
------------------------------------------------------------------

diff file1 file2
сравнение двух файлов

diff dir1 dir2
сравнение двух директорий

diff -r dir1 dir2
сравнение двух директорий, рекурсивно сравнивая еще и поддиректории
также, есть опция -q, она позволяет только сообщить о различающихся файлах, не выводить саму разницу 


md5sum file1
выводит хэш сумму md5 для файла file1 (выводит, естественно, в stdout)


sort file1
считывает ASCII файл file1 и выводит его в отсортированном виде
сортировка - построчно; можно сортировать по ключу, т.е. какому-то одному столбцу (-k) 
можно сортировать не только лексикографически, но и по численным значениям (-n), по числам вида 20K, 1G (-h),...
и т.д., см. man sort


uniq file1
или
cat file1 | uniq
убрать повторы строк и вывести в stdout (при этом можно вывести число повторов: -c), 
либо наоборот вывести только повторы (-d, тут тоже можно вывести их число: -c)
входные данные могут идти из файла, либо из stdin
по умолчанию убираются повторы только из соседних строк; чтобы убрать все повторы, надо входные данные отсортировать, напр.
cat file1 | sort | uniq = вывести список уникальных строк из file1


comm sfile1 sfile2
считывает два отсортированных файла и выводит в трех столбцах разность файлов и их пересечение, т.е. sfile1\sfile2, sfile2\sfile1, sfile1/\sfile2
иными словами, выводит уникальную часть каждого из файлов в столбцах 1, 2, и выводит общую часть в столбце 3.
для сортировки сырых файлов удобно брать process substitution:
comm <(sort file1) <(sort file2)


------------------------------------------------------------------
--=====        Поиск файлов, гибкое задание команд         =====--
------------------------------------------------------------------

find dir1 [-maxdepth 2] [-name "file1"] [-iname "FILE1"] [-type f] [-atime n] [-mtime n] [-exec cmd1 {} \;]
поиск файлов и директорий в dir1 и поддиректориях
если dir1 опущено, либо указано . то поиск идет, начиная с текущей директории
список найденных файлов выводится в stdout, а [некоторые] опции для find таковы:
-maxdepth N = искать во вложенных директориях с уровнем вложенности <= N, N=1 означает только саму директорию dir1
-name "file1" = шаблон для имени файла/директории; взято в кавычки, чтобы можно было использовать выражения вида "file1*"
-iname "FILE1" = как name, но нечувствительно к регистру
-type f = ищутся файлы
-type d = ищутся директории
-atime n = время доступа (access) ровно n дней назад
-atime +n = время доступа больше n дней назад
-atime -n = время доступа меньше n дней назад
-mtime n = время модификации, аналогично atime
-exec cmd1 {} \; = для каждого найденного имени файла/дирекории file_123 будет выполняться команда cmd1 file123 
(т.е. имя файла подставится вместо всех вхождений {})

простой пример: пустая команда
find
отобразит все файлы и поддиректории текущей директории

find . -name "*.txt" -exec du -h {} \; | sort -h
в текущей директории (и всех поддиректориях) найти все файлы *.txt, вывести их размер (du -h {}), результат упорядочить по возрастанию размера (sort -h)


xargs -I{} cmd1 ...{}...{}... 
если в такую команду xargs подать stdin, состоящий из нескольких строк str1, str2, str3, 
то будет выполнено cmd1 [несколько раз], с заменой всех {} на соответствующие строки str1,..., то есть будет выполнено:
cmd1 ...str1...str1... 
cmd1 ...str2...str2... 
cmd1 ...str3...str3... 

для понимания, можно рассмотреть команду:
seq 1 5 | xargs -I{} echo --{}--{}--
она запустит echo пять раз, выдав:
--1--1--
--2--2--
--3--3--
--4--4--
--5--5--

пример использования xargs:
find . -name '*.txt' | xargs -I{} cp {} dir1
1) найти в текущей директории (и поддиректориях) файлы *.txt 
2) каждый такой файл скопировать в dir1 (cp {} dir1)
конкретно для этого примера надо проявлять осторожность: при совпадении имен файлов, найденных в разных поддиректориях, 
все они будут скопированы в одно место, перезаписав друг друга

еще пример - *** поиск по содержимому файлов: во всех файлах найти XXX ***
find . -name '*.txt' | xargs -I{} grep -n --color XXX {} /dev/null
1) найти в текущей директории (и поддиректориях) файлы *.txt
2) в этих файлах найти строку/шаблон XXX, и вывести на экран (stdout) имена файлов с найденным XXX, а также номера соотв. строк (-n)
опция --color здесь подключает раскраску, упоминание фиктивного пустого файла /dev/null позволяет печатать имена найденных файлов

то же самое можно сделать при помощи самого find:
find . -name '*.txt' -exec grep -n --color XXX {} /dev/null \;


------------------------------------------------------------------
--=====                      Процессы                      =====--
------------------------------------------------------------------

ps ax
вывод всех рабочих процессов

ps ax | wc -l
вывести кол-во рабочих процессов


top
отобразить в реальном времени верхние процессы


------------------------------------------------------------------
--=====        Завершение процессов и фоновый режим        =====--
------------------------------------------------------------------

Запуск команды cmd в фоновом режиме:
cmd &

Фоновый режим означает, что задача запускается, но в командной строке можно продолжать печатать новые команды, не дожидаясь завершения старой.

Ctrl+C = завершить задачу (обычную, не из фонового режима)
Ctrl+Z = приостановить задачу (происходит возвращение в режим командной строки, а задача "замораживается")
jobs = список фоновых и приостановленных задач
bg N = продолжить приостановленную задачу номер N в фоновом режиме (background), номер N - такой же, как написано в jobs
fg N = продолжить приостановленную задачу номер N в обычном режиме (foreground)

kill -9 22071
силой завершить процесс с PID=22071 (или любым другим)
опцию "минус девять" можно опустить, она просто означает завершение задачи всеми силами

как найти PID какого-либо процесса (напр. notepad++):
ps ax | grep notepad++
и далее смотреть число (скорее всего, четырехзначное)

kill -9 %N
силой завершить процесс с номером N из jobs (этот номер пишется в квадратных скобках при вызове jobs)


------------------------------------------------------------------
--=====        Поиск, замена, выбор строк/стролбцов        =====--
------------------------------------------------------------------

grep [options] string1 file1
найти строки в файле file1 (можно задать и более одного файла), содержащие шаблон string1, и вывести их.
* вместо file1 можно в качестве входных данных использовать stdin, например: cmd1 | grep string1
* в варианте поиска по файлу (file1), grep полезен для поиска каких-либо ключевых слов.
* grep может быть полезен в сочетании с find, напр. см. пример в xargs (выше)
опции:
-i = игнорировать регистр
--color = выделить совпадения цветом
-n = показывать номера строк
-B2 = вывести 2 строки до каждого совпадения (типа, чтоб видеть контекст)
-A3 = вывести 3 строки после каждого совпадения
-C1 = вывести 1 строку до и после каждого совпадения
-v = вывести все строки без совпадений
-c = подсчитать совпадающие/несовпадающие строки


cut -f 3 file1
прочитать файл file1 и вывести столбец 3 (или любой другой); разделитель (отличный от TAB) можно задать в опции -d


tr -d SET1
взять stdin, убрать из него все символы, находящиеся в SET1, вывести в stdout
если нужно работать с файлом, то его надо сначала перевести на stdin, для этого есть много способов:
cat file1 | tr -d SET1
tr -d SET1 < file1
tr -d SET1 < <(cat file1)

команда tr может не только удалять, но и заменять символы, см. man tr

------------------------------------
--       sed: stream editor       --
------------------------------------

Выборка определенных строк:
sed -n '15p;21,27p;2~3p;32q' file1
из файла file1 вывести в stdout строки, чьи номера заданы последовательностью команд в кавычках, в примере выше:
строка 15; строки 21-27; строки начиная с 2, с шагом 3; закончить просмотр на строке 32; 
при выводе строки будут идти в порядке возрастания номеров, и со всеми повторами (если команд было много)

Замена слов / регулярных выражений:
sed -i 's/old_word/new_word/g' file1
заменить в file1 old_word на new_word; здесь old_word может быть как словом, так и регулярным выражением (шаблоном)
file1 будет изменен!
чтобы не менять file1, команда sed может работать и с stdin; затем надо перенаправить stdout в новый файл file2:
cat file1 | sed 's/old_word/new_word/g' > file2
в строке 's/old_word/new_word/g' символ 'g' означает заменять все совпадения; без него заменится только первое совпадение в строке

*** Regular Expressions ***
как работают регулярные выражения - см. в интернете, некоторые простые правила указаны ниже:
^ - начало строки
$ - конец строки
m? - 0 или 1 символ m
m* - 0 или более символов m
m+ - 1 или более символов m
. - один любой символ, кроме "новой строки"; отсюда .* - любое число любых символов
\s - один любой "пробелоподобный" символ (типа пробела, табуляции,...)

для sed, в режиме замены регулярного выражения (шаблона) old_word на слово new_word, 
в new_word можно ссылаться на найденную часть текста, удовлетворяющую шаблону, при помощи &
например:
echo Ut queant laxis Resonare fibris Mira gestorum Famuli tuorum | sed 's/.[mn]/|&|/g'
шаблон .[mn] удовлетворяет двум символам, где первый символ - любой, а второй - буква m или n
все найденные выражения заменятся на |&|, т.е. на сами себя, окруженные ||, и команда выдаст:
Ut que|an|t laxis Res|on|are fibris Mira gestor|um| F|am|uli tuor|um|

транслитерировать символы (по заданному правилу), т.е. перевести один набор в другой:
sed 'y/source/destin/'
например:
echo Ut queant laxis Resonare fibris Mira gestorum Famuli tuorum | sed 'y/abcdefghijkl/абцдефгхижкл/'
результат: Ut quеаnt лаxиs Rеsonаrе фибrиs Mиrа геstorum Fаmuли tuorum

добавить текст begin_add в начале каждой строки (пример ниже перезапишет файл; чтоб не перезаписывать - см. выше):
sed -i 's/^/begin_add/' file1
здесь символ ^ маркирует начало строки

убрать в конце каждой строки текст rm_end:
sed -i 's/rm_end$//' file1
здесь символ $ маркирует конец строки

убрать пустые строки:
sed -i '/^\s*$/d' file1
здесь ^, $ означают начало и конец строки
\s означает любой "пробелоподобный" символ, \s* означает любое число таких символов

внутри кавычек можно одновременно задавать несколько команд для sed - через ;
например,
sed -i 's/rm_end$//; s/^/begin_add/' file1.txt

замена Windows-переносов строк (CRLF) на Linux-переносы (LF):
tr -d '\015' < win_file > linux_file
здесь \015 - восьмеричная запись символа CR, а про команду tr см. выше

замена Linux-переносов строк (LF) на Windows-переносы (CRLF):
sed -i 's/$/\r/' file1
здесь $ означает конец строки, \r означает символ CR, а символ LF вставляется автоматически

вставка в специальные места данного файла содержимого другого файла:
sed -i '/old_word/ r file2' file1
после строк файла file1, содержащих регулярное выражение old_word, будет вставлено содержимое файла file2
вставка делается после строк, а не посередине строк!


------------------------------------------------------------------
--=====                       Скрипты                      =====--
------------------------------------------------------------------

Скриптом может быть любой текстовый файл (убедиться, что строки разделены LF, а не CRLF)
Любые команды bash могут стоять в скрипте
Запуск скрипта script1 - как для обычной программы: ./script1
Если скрипт не запускается, возможно у него не поставлены права на запуск 
(после ls -l печатается строка типа -rw-rw-r--, показывающая права на чтение, запись, исполнение для пользователя, группы, прочих людей)
Чтобы добавить права на запуск/исполнение: chmod u+x script1
(после этого ls -l выдаст -rwxrw-r--, появилось "x" на 4-й позиции, т.е. право на исполнение для пользователя)


* Комментарий в скрипте начинается с #


* Задание переменных делается просто, напр.
Var1=123abc
Использование переменных - при помощи $, напр.
echo $Var1


* Аргументы скрипта можно использовать как переменные:
если в script1 стоит команда echo --$0--$1--$2--
то ./script1 hello world! напечатает: --./script1--hello--world!--
$0 имеет значение, равное имени скрипта
$1 - значение первого аргумента, и т.д.
$* - значение всех аргументов в одной переменной


* Цикл for (также см. man bash, поиск /for name)
Его можно сделать и в командной строке, но удобнее его делать в скрипте:

for v in one two three
do
    # между do и done идет тело цикла; значения переменных возвращаются при помощи $[имя переменной]
    echo Hello World, I am $v
done

диапазон цикла for можно задать не только явным списком слов, но и численными пределами:
for i in {1..5}
for i in {1..10..2} -- тут также задается инкремент (2)
for i in $(seq 1 2 10) -- равнозначно варианту на предыдущей строке


* Задание функций, напр.
add()
{
	echo $1 + $2 = $(expr $1 + $2)
	# expr оценивает целочисленные, логические или строковые выражения
}
Вызов функции:
add 10 20


* Чтение значений из stdin (stdin может задаваться через piping, не только с клавиатуры):
read val
echo you\'ve typed $val
также см. man bash, поиск /read \[-ers\]

несколько значений из stdin (стоящих в одной строке, разделенных пробелами/табуляцией) можно считать в несколько переменных:
read v1 v2 v3

можно  в цикле while считывать все строки, которые пришли в stdin при помощи piping:
while read val
do
    echo You\'ve entered $val
done
если stdin (посредством piping) состоит из нескольких строк (напр., ls -l | ./script1), то цикл while будет повторяться,
пока val последовательно перебирает все строки


* Все команды и программы после своего завершения возвращают exit status, 
который равен 0 в случае успешного завершения, и имеет ненулевое значение в случае ошибки в программе


* Условный оператор if (также см. man bash, поиск /if list)
if cmd0
then
  cmd1
else
  cmd2
fi
Если cmd0 завершилась со статусом 0 (успешно),
то
выполняется cmd1
иначе
выполняется cmd2

Вместо проверки эксит статуса команды cmd0 можно задавать более сложные выражения при помощи
test expr1
или
[ expr1 ]
эти команды оценивают выражение expr1 и выходят со статусом 0 (если выражение истинно) или не-ноль (иначе)
expr1 может включать логические операторы, а также оценивать отношения с целыми числами, строками, файлами, напр.
test -f file1
выходит со статусом 0, если file1 - существующий файл
детали см. в man test, man bash (поиск /test expr)


Команды можно вызывать в зависимости от эксит статуса других команд, напр:
cmd1 && cmd2 --- тут cmd2 запускается только если cmd1 вышла со статусом 0
cmd1 || cmd2 --- тут cmd2 запускается только если cmd1 вышла с ненулевым статусом
Пример (здесь на входе в скрипт нужен pipe с несколькими строками, содержащими имена файлов и еще какой-нибудь текст):
while read val
do
  # проверяем, что в val стоит корректное имя файла; 
  # если нет, то выполняется continue (т.е. переход на следующую итерацию цикла); 
  # если да, то выполняется echo, и только потом - следующая итерация
  [ -f "$val" ] || continue

  echo $val
done
Внимание, чтобы пример выше работал нормально, входной pipe должен идти из текстового файла с переносами в стиле Linux (LF)
Для Windows-переносов (CRLF) символ CR будет прицепляться сзади к имени файлов, и проверка -f "$val" их не распознает


